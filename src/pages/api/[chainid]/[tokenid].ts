import type { NextApiRequest, NextApiResponse } from 'next'
import Cors from 'cors'
import { ethers } from "ethers"

import BaseTokenAbi from "./../../../abis/BaseToken.json";

/*
 * Overview:
 *
 * Since each SubToken may have different metadata stored within it,
 * we need to provide a way to generate that metadata based on the token.
 *
 * Each subtoken is listed in decoders with its associated metadata abi.
 */

const cors = Cors({
  methods: ['GET'],
})

interface MetadataResult {
  name: string;
  image: string;
  description: string;
}

/*
 * Enter each supported chain and associated RPC here
 */
interface ChainDict {
  [key: string]: string;
}
const chains: ChainDict = {
  43113: 'https://api.avax-test.network/ext/bc/C/rpc',
  10101: 'https://io.gogopool.com',
};

/*
 * Providers are automatically generated by the chainid and rpc url in chains
 */
interface ProviderDict {
  [key: string]: ethers.providers.Provider;
}
const providers: ProviderDict = Object.fromEntries(
  Object.entries(chains)
    .map(([id, url]: [string, string]) =>
      [id, new ethers.providers.JsonRpcProvider(url)])
);

/*
 * Enter each proxy implementation of SoulBoundBaseToken here
 * This provides access to the methods available for the base token (metadata lookup)
 */
interface ContractDict {
  [key: string]: ethers.Contract;
}
const contracts: ContractDict = Object.fromEntries(
  Object.entries({
    43113: '0x0587CfC662555f0a01Ba07C6b44B73C88008309a',
    10101: '0xa6421E906a749B357Da4C10aEB0d8d588939862C',
  })
    .map(([id, addr]: [string, string]) =>
      [id, new ethers.Contract(addr, BaseTokenAbi, providers[id])])
);


/*
 * These are each of the subtokens on each chain
 *
 * Each subtoken needs an implementation to know how to respond with JSON metadata
 */
interface DecoderDict {
  [key: string]: {
    [key: string]: {
      abi: string[];
      json: (chainid: string, tokenid: string, decoded: ethers.utils.Result) => Promise<MetadataResult>;
    };
  };
}
const decoders: DecoderDict = {
  43113: {
    // ExampleToken
    '0x64aB9B8647181dee1620A094F56cdafd98D84Cc7': {
      abi: ['string'],
      json: async (chainid: string, tokenid: string, decoded: ethers.utils.Result) => ({
        name: 'example',
        image: 'image',
        description: 'desc',
      }),
    },
  },
  10101: {
    // AVAXSummit2023Token
    '0x7e20936d9ea7A10c65c09190fdc277811c0a2472': {
      abi: ['uint256'],
      json: async (chainid: string, tokenid: string, decoded: ethers.utils.Result) => {
        const kind = decoded[0].toString();
        console.log(decoded);
        return {
          name: `Alice in Avaland #${kind}`,
          image: `https://metadata.achievemint.io/avaxsummit2023/${kind}.png`,
          description: 'Alice in Avaland',
        }
      },
    },
    // AlphaTester
    '0x0a320D4828e3492BE966d9e7DFfBbDF7320d12b2': {
      abi: [],
      json: async (chainid: string, tokenid: string, decoded: ethers.utils.Result) => ({
        name: `Alpha Tester`,
        image: `https://metadata.achievemint.io/alphatester/Badge.svg`,
        description: 'Alpha Tester',
      }),
    },
    // ChiknMerch
    '0x788bf736231a195E7a704C5469c61b2961DF3472': {
      abi: ['string'],
      json: async (chainid: string, tokenid: string, decoded: ethers.utils.Result) => ({
        name: `Chikn Merch`,
        image: `https://metadata.achievemint.io/chiknmerch/chikn.png`,
        description: 'Chikn Merch',
      }),
    },
  }
}


// Helper method to wait for a middleware to execute before continuing
// And to throw an error when an error happens in a middleware
function runMiddleware(
  req: NextApiRequest,
  res: NextApiResponse,
  fn: Function
) {
  return new Promise((resolve, reject) => {
    fn(req, res, (result: any) => {
      if (result instanceof Error) {
        return reject(result)
      }

      return resolve(result)
    })
  })
}

const abiCoder = new ethers.utils.AbiCoder();
export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== 'GET') {
    return res.status(405).json({ msg: 'method not allowed' })
  }

  const { chainid, tokenid } = req.query as { chainid: string, tokenid: string };

  // apply cors
  await runMiddleware(req, res, cors)

  if (! chains.hasOwnProperty(chainid)) {
    return res.status(400).json({ msg: 'chain not enabled' })
  }

  try {
    const subtoken = await contracts[chainid]._tokenIdToSubtoken(tokenid);
    if (subtoken === '0x0000000000000000000000000000000000000000') {
      return res.status(404).json({msg: "tokenid or subtoken not found"});
    }
    const metadata = await contracts[chainid].metadata(tokenid);

    const decoded = abiCoder.decode(decoders[chainid][subtoken].abi, metadata)
    const json = await decoders[chainid][subtoken].json(chainid, tokenid, decoded);

    // cache for 7 days
    // on vercel, redeploy will trigger cache purge
    res.setHeader('Cache-Control', 's-maxage=604800');
    return res.status(200).json(json)
  } catch (e) {
    return res.status(500).json({
      msg: JSON.stringify(e),
    });
  }
}
