import type { NextApiRequest, NextApiResponse } from 'next'
import Cors from 'cors'
import { ethers } from "ethers"

import BaseTokenAbi from "./../../../abis/BaseToken.json";

/*
 * Overview:
 *
 * Since each SubToken may have different metadata stored within it,
 * we need to provide a way to generate that metadata based on the token.
 *
 * Each subtoken is listed in decoders with its associated metadata abi.
 */

const cors = Cors({
  methods: ['GET'],
})

interface MetadataResult {
  name: string;
  image: string;
  description: string;
}

/*
 * Enter each supported chain and associated RPC here
 */
interface ChainDict {
  [key: string]: string;
}
const chains: ChainDict = {
  1000: 'https://api.avax-test.network/ext/bc/C/rpc',
};

/*
 * Providers are automatically generated by the chainid and rpc url in chains
 */
interface ProviderDict {
  [key: string]: ethers.providers.Provider;
}
const providers: ProviderDict = Object.fromEntries(
  Object.entries(chains)
    .map(([id, url]: [string, string]) =>
      [id, new ethers.providers.JsonRpcProvider(url)])
);

/*
 * Enter each proxy implementation of SoulBoundBaseToken here
 * This provides access to the methods available for the base token (metadata lookup)
 */
interface ContractDict {
  [key: string]: ethers.Contract;
}
const contracts: ContractDict = Object.fromEntries(
  Object.entries({
    1000: '0x0587CfC662555f0a01Ba07C6b44B73C88008309a',
  })
    .map(([id, addr]: [string, string]) =>
      [id, new ethers.Contract(addr, BaseTokenAbi, providers[id])])
);


/*
 * These are each of the subtokens on each chain
 *
 * Each subtoken needs an implementation to know how to respond with JSON metadata
 */
interface DecoderDict {
  [key: string]: {
    [key: string]: {
      abi: string[];
      json: (chainid: string, tokenid: string, decoded: ethers.utils.Result) => Promise<MetadataResult>;
    };
  };
}
const decoders: DecoderDict = {
  1000: {
    // ExampleToken
    '0x64aB9B8647181dee1620A094F56cdafd98D84Cc7': {
      abi: ['string'],
      json: async (chainid: string, tokenid: string, decoded: ethers.utils.Result) => ({
        name: 'example',
        image: 'image',
        description: 'desc',
      }),
    },
  }
}


// Helper method to wait for a middleware to execute before continuing
// And to throw an error when an error happens in a middleware
function runMiddleware(
  req: NextApiRequest,
  res: NextApiResponse,
  fn: Function
) {
  return new Promise((resolve, reject) => {
    fn(req, res, (result: any) => {
      if (result instanceof Error) {
        return reject(result)
      }

      return resolve(result)
    })
  })
}

const abiCoder = new ethers.utils.AbiCoder();
export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const { chainid, tokenid } = req.query as { chainid: string, tokenid: string };

  // apply cors
  await runMiddleware(req, res, cors)

  if (! chains.hasOwnProperty(chainid)) {
    return res.status(400).json({ msg: 'chain not enabled' })
  }

  try {
    const subtoken = await contracts[chainid]._tokenIdToSubtoken(tokenid);
    const metadata = await contracts[chainid].metadata(tokenid);

    const decoded = abiCoder.decode(decoders[chainid][subtoken].abi, metadata)
    const json = await decoders[chainid][subtoken].json(chainid, tokenid, decoded);

    // cache for 7 days
    // on vercel, redeploy will trigger cache purge
    res.setHeader('Cache-Control', 's-maxage=604800');
    return res.status(200).json(json)
  } catch (e) {
    return res.status(500).json({
      msg: JSON.stringify(e),
    });
  }
}
